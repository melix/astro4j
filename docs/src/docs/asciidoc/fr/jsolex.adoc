= JSol'Ex
Cédric Champeau
:icons: font
:docinfo: shared

JSol'Ex est un traitement d'images solaires produites par l'intermédiaire du http://www.astrosurf.com/solex/[Sol'Ex de Christian Buil].
Il permet de traiter les fichiers SER capturés avec cet instrument pour produire des images du disque solaire, de manière similaire à http://valerie.desnoux.free.fr/inti/[INTI de Valérie Desnoux].
S'il est principalement conçu pour traiter les images produites par Sol'Ex, il est possible qu'il donne de bons résultats sur d'autres héliospectrographes.

JSol'Ex est un logiciel libre sous licence Apache 2, écrit en Java et fourni à titre gratuit sans aucune garantie.

== Téléchargement

link:https://jsolex.s3.eu-west-3.amazonaws.com/jsolex-windows-latest/{prefixName}-{version}.msi[icon:windows[] Télécharger JSol'Ex (Windows), role="badge"]
link:https://jsolex.s3.eu-west-3.amazonaws.com/jsolex-ubuntu-latest/{prefixName}_{version}_amd64.deb[icon:linux[] Télécharger JSol'Ex (Linux), role="badge"]
link:https://jsolex.s3.eu-west-3.amazonaws.com/jsolex-macos-latest/{prefixName}-{version}.pkg[icon:apple[] Télécharger JSol'Ex (Mac), role="badge"]

JSol'Ex peut être téléchargé sur https://github.com/melix/astro4j/releases[cette page].
Des installateurs sont disponibles pour Linux, Windows et MacOS.

Alternativement, vous pouvez lancer JSol'Ex en téléchargeant les sources puis en exécutant la commande:

[source,bash]
----
./gradlew jsolex:run
----

== Traitement d'une vidéo

JSol'Ex ne peut traiter que les fichiers SER, vous devez donc configurer votre logiciel de capture pour utiliser ce format.
La fenêtre principale se présente sous cette forme:

image::main-window-fr.jpg[]

Dans le menu "Fichier", sélectionnez "Ouvrir un fichier SER".
Choisissez votre fichier, la fenêtre suivante devrait s'ouvrir:

image::params-1-fr.jpg[]

Cette fenêtre est le point d'entrée de la configuration du traitement.
Vous pouvez préciser:

- la longueur d'onde d'observation: s'il n'est pas obligatore de remplir ce champ, le faire vous permettra de bénéficier de la coloration automatique. En cliquant sur les "..." vous disposez de la possibilité d'ajouter vos propres raies si elles ne sont pas listées
- décalage en pixels : par défaut, le logiciel trouve la raie la plus sombre dans l'image et calcule un polynôme de second degré pour modéliser cette raie. L'image est reconstituée en prenant les pixels au centre de la raie (décalage = 0). Il vous est possible d'entrer un décalage en pixels pour aller par exemple vers le continuum, ou trouver une raie plus difficile à identifier (ex. Hélium) à partir de la raie la plus sombre.
- le décalage Doppler est utilisé uniquement lorsque vous observez en raie h-alpha pour générer une image Doppler. Par défaut, le logiciel utilise 2 images décalées de 3 pixels pour reconstituer une image en couleur.
- Correction angle P : lorsque cette case est cochée, l'angle P du soleil sera calculé automatiquement à partir de la date d'observation (disponible dans le fichier SER). Les images seront automatiquement corrigées de cet angle, pour que le Nord soit bien en haut. Ce paramètre n'affecte pas les images générées avec ImageMath, qui doivent faire leur propre correction.
- Rotation : permet d'effectuer une rotation à gauche ou à droite (90 degrés) de l'image. Ceci peut par exemple être utile dans le cas d'un scan fait en déclinaison, pour corriger l'orientation. Ce paramètre n'affecte pas les images crées avec ImageMath.
- Rognage : permet d'effectuer un rognage automatique de l'image après correction géométrique. Il existe plusieurs modes:
* Aucun: pas de rognage (par défaut)
* Largeur d'origine : l'image sera redimensionnée dans un carré de la taille de la largeur de la vidéo d'origine. Idéal pour les disques solaires complets.
* Rayon (x...) : l'image sera redimensionnée en fonction du rayon du disque solaire, en appliquant un multiplicateur. Peut-être utile par exemple lorsque le disque est tronqué et que l'on veut avoir une image carrée permettant de "remettre" la portion à sa place.
- Forcer la valeur du tilt : lors de la correction géométrique d'image, JSol'Ex calcule une ellipse pour modéliser le disque solaire reconstitué. Cette ellipse est utilisée pour calculer des paramètre comme l'angle de tilt. Si le calcul effectué par le logiciel est erroné, vous disposez de la possibilité de surcharger la valeur calculée.
- Forcer le rapport X/Y : de manière similaire, sur certaines images dans des raies difficiles, l'ellipse peut ne pas parfaitement correspondre au disque solaire et ne pas reconstituer un soleil parfaitement circulaire. Vous pouvez surcharger le rapport détecté pour corriger ces problèmes
- Inverser l'axe horizontal/vertical : permet de retourner l'image verticalement et horizontalement pour avoir le Nord et l'Est bien orientés
- Redimensionner au maximum: peut être utilisé si votre vidéo est sur-échantillonnée et que vous souhaitez conserver la résolution maximum. Ceci arrive par exemple si vous faites des scans à basse vitesse (ex, sidérale).

WARNING: Activer ce paramètre peut produire des images sensiblement plus grandes et entraîner une forte pression mémoire. Il n'est pas recommandé d'activer ce paramètre.

== Paramètres d'amélioration de l'image

Cette section permet de configurer les transformations qui seront appliqueés aux images de façon à améliorer leur aspect esthétique.

image::params-2-fr.jpg[]

- Paramètres CLAHE : permet de configurer l'algorithme d'amélioration de contraste CLAHE.
Il est possible de configurer la taille des tuiles utilisées pour calculer les histogrammes, la résolution de l'histogramme et le facteur de clipping.

Viennent ensuite les paramètres de correction de bandes, qui permettent de corriger les bandes transversales qui peuvent apparaître sur les images par exemple à cause de poussières sur la fente.

- Largeur de correction de bande : c'est la largeur des bandes qui sont utilisées pour l'algorithme de correction de transversallium. L'algorithme calcule la valeur moyenne des pixels dans ces bandes et corrige la luminosité d'une ligne en fonction de cette valeur.
- Nombre de passes de correction de bande : plus vous ferez de passes, plus il sera possible de corriger de gros défauts, au prix d'une image moins contrastée et/ou moins lumineuse

Une autre section permet de configurer la déconvolution des images.
Par défaut, aucune déconvolution n'est appliquée, mais vous pouvez choisir l'agorithme de déconvolution et ses paramètres.

Pour la déconvolution de Richardson-Lucy, vous pouvez choisir la taille du PSF synthétique, le facteur sigma et le nombre d'itérations.

Enfin, vous pouvez choisir d'appliquer un filtre d'amélioration des détails à la fin du traitement en cochant la case "aiguiser les images".

== Paramètres d'observation

Les paramètres d'observation sont utilisés lorsque vous enregistrez vos images au format FITS, pour remplir certaines métadonnées.
Elles servent aussi à calculer le graphique de longueur d'ondes.
A noter qu'à ce stade, nous ne recommandons pas d'envoyer les images générées par JSol'Ex sur la base de données BASSS2000, les champs de métadonnées entrés n'étant pas exactement les mêmes.

image::params-3-fr.jpg[]

Voici les champs disponibles dans JSol'Ex:

- Observateur : personne qui a effectué l'observation
- Adresse email : adresse e-mail de l'observateur
- Instrument : pré-rempli avec "Sol'Ex"
- Télescope : votre lunette ou télescope utilisé avec votre Sol'Ex
- Longueur focale et ouverture
- Latitude et longitude du site d'observation
- Caméra
- Date : pré-rempli avec les métadonnées du fichier SER, en zone UTC
- Binning : le binning appliqué à la caméra lors de l'acquisition
- Taille des pixels : la taille des pixels de la caméra, en microns

== Autres paramètres disponibles

image::params-4-fr.jpg[]

- Supposer vidéo mono : si cette cache est cochée, JSol'Ex n'essaiera pas de faire un dématriçage de la vidéo d'entrée, ce qui permet d'accélérer considérablement les temps de traitement. En règle générale, vos vidéos seront en mono, il est donc utile de conserver cette case cochée.
- Enregistrement automatique des images : si cette case est cochée, toutes les images générées sont automatiquement enregistrées sur disque. Dans le cas contraire, vous devrez dans l'interface qui affiche les images générés appuyer sur le bouton "Enregistrer" pour conserver les images produites
- Générer des images de debug : permet de générer des images telles que la reconnaissance de contours, la reconnaissance d'ellipse/tilt, l'image moyenne. Utile pour vérifier si le logiciel ne se comporte pas correctement sur votre vidéo et que vous souhaitez vérifier là où il se trompe
- Générer des fichiers FITS : permet de générer des fichiers FITS, non destructifs, en plus des images PNG

[[modele-noms-fichier]]
== Modèles de noms de fichier

Par défaut, JSol'Ex enregistre les images produites dans un sous-dossier correspondant au nom de la vidéo, et dans ce sous-dossier un autre sous-dossier par type d'image (raw, debug, traitées, etc...).
Si ce modèle ne vous convient pas, vous pouvez créer vos propres modèles de nommage, en cliquant sur les "...":

image::params-5-fr.jpg[]

Un modèle de nommage consiste en un label (un nom), mais surtout un modèle dont les composantes sont des jetons entre `%`.

Voisi les jetons disponibles:

- `%BASENAME%` est le nom de base du fichier SER, sans l'extension
- `%KIND%` correspond au type d'image générée (raw, debug, ...)
- `%LABEL%` est l'identifiant des images, par exemple `recon`, `protus`, etc...
- `%CURRENT_DATETIME%` est la date et l'heure de traitement
- `%CURRENT_DATE%` est la date de traitement
- `%VIDEO_DATETIME%` est la date et heure de la vidéo
- `%VIDEO_DATE%` est la date de la vidéo
- `%SEQUENCE_NUMBER%` est le numéro de séquence dans le cas d'un traitement en mode batch (avec 4 chiffres, par ex. `0012`)

Par exemple, pour créer un modèle pour mettre toutes vos images dans un même dossier peut être :

`%BASENAME%/%SEQUENCE_NUMBER%_%LABEL%`

Le champ "exemple" donne une idée de ce qui sera généré.

== Lancer un traitement

Vous avez le choix entre 3 modes de traitement.

- Le mode "rapide" ne produira que 2 images : l'image brute reconstituée, qui permet de se donner une idée de la circularité du disque et donc du potentiel sous-échantillonage, et une image corrigée géométriquement. C'est un mode particulièrement utile lors des premières acquisitions, par exemple de temps de régler le tilt correctement. Combiné au fait de ne pas sauvegarder automatiquement les images, il peut vous faire gagner un temps précieux et de l'espace disque !
- Le mode "complet" produira l'intégralité des images que peut produire JSol'Ex. En fonction de la raie spectrale choisie, certaines images seront disponibles ou non. Par défaut, le logiciel produira:
    - l'image brute reconstituée
    - une version géométriquement corrigée et "étalée" (contraste amélioré)
    - une version colorisée (si la raie choisie dispose d'un profil de colorisation)
    - une version en négatif
    - une éclipse virtuelle, permettant de simuler un coronagraphe
    - une version "mix" combinant l'éclipse virtuelle et l'image colorisée
    - une image Doppler
- le mode "personnalisé" permet de choisir plus précisément les images générées, voire de générer des images non prévues à l'origine par le logiciel (voir la <<#custom_images,section suivante>>).

=== Affichage des images produites

Lorsque les images sont produites, elles apparaissent au fur et à mesure en onglets.
Il vous est alors possible, en fonction des images, de modifier des paramètres de constraste et d'enregistrer les images.

image::image-display-fr.jpg[]

Vous pouvez zoomer dans les images en utilisant la molette de la souris.
Un clic droit vous permettra d'ouvrir l'image générée dans votre explorateur de fichiers ou dans une nouvelle fenêtre.

== Mode surveillance de répertoire

Lors de la mise au point, il peut être utile de traiter "à la chaîne" de nouvelles vidéos jusqu'à avoir obtenu un résultat satisfaisant (image centrée, mise au point correcte, etc.).
JSol'Ex offre une façon simple de gagner du temps, en surveillant un dossier : les vidéos qui apparaissent dans le dossier seront automatiquement traitées.

Pour ce faire, dans le menu fichier, sélectionnez "Surveiller un dossier" puis sélectionnez le dossier dans lequel seront enregistrés vos fichiers SER (par exemple là où SharpCap va enregistrer).

JSol'Ex bascule en mode "surveillance" que vous pouvez interrompre en cliquant sur le bouton en bas à gauche.

Ouvrez maintenant votre logiciel de capture et enregistrez une nouvelle vidéo.
Lorsque vous rebasculerez sur JSol'Ex, le logiciel ouvrira automatiquement la fenètre de paramétrage.
Choisissez vos options et lancez le traitement.

Une fois le résultat obtenu, rebasculez sur le logiciel d'acquisition et enregistrez une nouvelle vidéo.
Lorsque vous rebasculerez sur JSol'Ex, cette fois-ci le logiciel réutilisera les paramètres utilisés lors du traitement de la première vidéo : vous obtiendrez donc rapidement une nouvelle image !

WARNING: Lorsque vous basculez de votre logiciel de capture à JSol'Ex, faites attention à ce que l'enregistrement soit terminé. Dans le cas contraire, le traitement serait lancé sur un fichier SER incomplet, ce qui échouera.

Lorsque vous avez terminé, cliquez sur le bouton "Interrompre la surveillance" en bas à gauche.

TIP: Vous pouvez combiner le fait d'être en mode surveillance avec le fait d'ouvrir une image dans une fenêtre externe (en faisant un clic droit sur l'image choisie). En effet, lors du traitement de la nouvelle vidéo, l'image dans la fenêtre sera automatiquement remplacée par la nouvelle version. Ceci peut par exemple être intéressant dans des présentations publiques, en ayant une fenêtre montrant simplement le résultat du traitement.

[[custom_images]]
== Personnalisation des images générées

Lorsque vous cliquez sur "Personnalisé" au lieu des modes "rapide" ou "complet", JSol'Ex vous permet de choisir bien plus précisément quelles images généres.

Il existe 2 modes : le mode _simple_ et le mode _ImageMath_.

Dans le mode simple, vous pouvez choisir la liste des images générées en cochant chacune d'entre elles, et vous pouvez aussi demander la génération d'images avec des décalages de pixels différents.

Par exemple, si vous souhaitez disposer d'images allant du continuum en passant par la raie explorée, vous pouvez entrer `-10;-9;-8;-7;-6;-5;-4;-3;-2;-1;0;1;2;3;4;5;6;7;8;9;10` ce qui aura pour effet de générer 21 images distinctes, pour des décalages de pixels entre -10 et 10.

Ceci peut être intéressant par exemple si vous les recombinez pour en faire un GIF animé ou une vidéo.

A noter que si vous cochez certaines images comme "Doppler", certains décalages sont automatiquement ajoutés à la liste (ex. -3 et 3).

Si ceci ne suffit pas, vous pouvez utiliser le mode avancé "ImageMath" qui est extrêmement puissant tout en restant simple d'accès.

[[imagemath]]
== ImageMath : scripts de calcul d'images
=== Introduction à ImageMath

Le mode ImageMath permet de générer des images en effectuant des calculs plus ou moins complexes sur des images générées.
Il repose sur un langage de script _simple_ mais suffisamment riche pour faire des traitement complexes.

Reprenons l'exemple précédent, dans lequel il s'agissait de générer l'ensemble des images pour des décalages allant de -10 à 10 pixels.
Dans le mode "simple", il nous a fallu entrer l'ensemble des valeurs à la main, séparés par des points-virgule.
Dans le mode "ImageMath", nous disposons d'un langage permettant de le faire.

Commençez par sélectionner le mode `ImageMath` dans la liste et cliquez sur "Ouvrir ImageMath".
L'interface suivante s'ouvre:

image::imagemath-1-fr.jpg[]

Dans la partie gauche, "Scripts à exécuter", nous trouvons la liste des scripts qui seront appliqués lors du traitement.
Les scripts sont des fichiers enregistrés sur votre disque, que vous pouvez partager avec d'autres utilisateurs.
Leur contenu est éditable dans la partie droite de l'interface.

Effacez le contenu du script d'exemple et remplacez le par:

[source]
----
range(-10;10)
----

Puis cliquez sur "sauvegarder".
Choisissez un fichier de destination et enregistrez.
Le script apparaît désormais dans la liste de gauche, il sera appliqué lors du traitement.

Cliquez alors sur "Ok" pour fermer "ImageMath" et ne conservez que "Après correction géométrique et étendue" dans la liste des images.

Cliquez sur "Ok" pour lancer le traitement, vous obtenez alors les images demandées:

image::imagemath-2-fr.jpg[]

=== Les fonctions d'ImageMath

Nous avons utilisé ici une seule fonction, `range`, qui a permis de générer en une seule instruction une vingtaine d'images, mais il existe de nombreuses fonctions.

Fonctions "unitaires":

- `img` demande une image à un décalage de pixels donné. Par exemple, `img(0)` est l'image centrée sur la raie, `img(-10)` est celle décalée de 10 pixels vers le haut.
- `list` crée une liste à partir des arguments. Par exemple `list(img(-3), img(3))`
- `avg` permet de calculer la valeur moyenne d'images, par exemple: `avg(img(-1), img(0), img(1))` calcule la moyenne des images aux décalages -1, 0 et 1. Il est aussi possible d'écrire: `avg(range(-1,1))`
- `max` permet de calculer la valeur maximale d'images, par exemple `max(img(-3), img(3))`. Le maximum est calculé pixel par pixel.
- `min` permet de calculer la valeur minimale d'images, par exemple `min(img(-3), img(3))`. Le minimum est calculé pixel par pixel.
- `range` permet de générer une suite d'images à des pixels décalés. Cette fonction prend au minimum 2 arguments, la valeur basse (inclue) et la valeur haute (inclue). Par exemple, `range(-5,5)` produira 11 images. Il est possible de générer une image tous les X pixels, en ajoutant un 3ème argument, le pas. Par exemple, `range(-5,5,5)` ne générera plus que 3 images, à -5, 0 et 5 pixels.
- `pow` permet de calculer une puissance d'une image. Par exemple, `pow(img(0), 2)` calcule le carré de l'image.
- `log` permet de calculer le logarithme d'une image. Par exemple, `log(img(0), 2)` calcule le logarithme en base 2.
- `exp` permet de calculer l'exponentielle d'une image. Par exemple, `exp(img(0))`.

Il est possible de faire des calculs sur les images, par exemple:

`(img(5)+img(-5))/2` est équivalent à `avg(img(5),img(-5))`.

Ou encore: `0.8*img(5) + 0.2*avg(range(0;10))`

Les autres fonctions disponibles sont:

- `adjust_gamma` permet d'appliquer une correction gamma à une image. Cette fonction accepte 2 paramètres : l'image et le facteur de correction gamma. Par exemple, `adjust_gamma(img(0), 2.2)`. Un gamma < 1 éclaircit l'image, un gamma > 1 la fonce.
- `auto_constrast` est une fonction d'amélioration du contraste crée spécifiquement pour les images Sol'Ex. Elle combine plusieurs techniques pour améliorer l'image. Cette fonction prend 2 arguments : l'image et un facteur de correction. Le facteur doit être supérieur à 1 et plus il est élevé, plus la correction sera forte. Par exemple : `auto_contrast(img(0), 1.5)`.
- `invert`, qui permet d'obtenir le négatif d'une image
- `invert`, generates a color inverted image
- `clahe` applique une https://en.wikipedia.org/wiki/Adaptive_histogram_equalization#Contrast_Limited_AHE[transformation d'histogramme adaptative (CLAHE)] sur votre image. Cette fonctiona accepte soit 2, soit 4 arguments. Dans la version courte, elle prend l'image et un facteur de clipping. Par exemple: `clahe(img(0); 1.5)`. Dans sa version longue, elle accepte 2 paramètres supplémentaires: la taille des tuiles utilisées pour calculer les histogrammes et la résolution de l'histogramme. Plus la résolution est élevée, plus la dynamique est élevée, mais plus vous devrez utiliser des tuiles petites. Par exemple: `clahe(img(0); 128; 256; 1.2)`.
- `adjust_contrast` permet d'appliquer un ajustement très simple du contraste, en coupant les pixels sous une limite minimale ou au-dessus de la limite maximale. Par exemple: `adjust_contrast(img(0), 10, 210)`. L'intervalle doit être entre 0 et 255.
- `asinh_stretch` permet d'appliquer la fonction d'étirement par arcsinus hyperbolique. Elle prend 3 paramètres: l'image, le point noir et le coefficient de stretch. Par exemple, `asinh_stretch(img(0), 200, 100)`.
- `linear_stretch` augmente la plage dynamique d'une image. Elle prend soit 1, soit 3 paramètres : l'image, puis optionellement les valeurs min et max des pixels (valeur comprise entre 0 et 65535). Par exemple: `linear_stretch(img(0))`
- `fix_banding` permet d'appliquer l'algorithme de corrections de bandes (ou transversallium). Il prend 3 arguments: l'image, la largeur de bande et le nombre d'itérations. Par exemple, `fix_banding(img(0), 10, 5)`.
- `remove_bg` permet de supprimer l'arrière plan d'une image. Ceci peut être utile lorsque le constraste est très faible (par exemple en raie hélium). Le processus calcule la valeur moyenne des pixels en dehors du disque, puis applique une suppression de l'arrière plan en fonction de la distance au limbe. Par exemple: `remove_bg(stretched)`. Une variante est disponible avec une tolerance: `remove_bg(stretched, 0.2)`. Plus la tolérance est proche de 0, moins la suppression est forte.

NOTE: Si vous ne connaissez pas la valeur du point noir, vous pouvez utiliser la valeur estimée par JSol'Ex, disponible dans une variable prédéfinie `blackPoint`: `asinh_stretch(img(0), blackPoint, 100)`

- `crop` permet de réduire l'image aux dimensions souhaitées. Cette fonction prend 5 paramètres: l'image à réduire, les coordonnées du point en haut à gauche, puis la largeur et la hauteur de l'image souhaitée. Par exemple: `crop(img(0), 100, 100, 300, 300)`.
- `crop_rect` permet de réduire l'image aux dimensions indiquées, en garantissant que le centre du disque solaire sera au centre de l'image. Par exemple: `crop-rect(img(0), 1024, 1024)`. Il n'y a pas de changement d'échelle : si le disque solaire n'entre pas dans les dimensions cibles, il sera tronqué.
- `autocrop2` effectue un rognage carré de l'image, centré sur le disque solaire, de manière similaire à `autocrop`, mais les dimensions de l'image rognée sont calculées avec un facteur du diamètre du disque. Par défaut, les dimensions de l'image rognée sont un multiple de 16. Par exemple, `autocrop2(img(0);1.1)` rognera autour de 1,1 fois le diamètre. `autocrop2(img(0);1.1;32)` fera la même chose, mais l'image résultante aura une largeur et une hauteur comme multiples de 32.
- `colorize` permet de coloriser une image. Elle prend au choix 2 ou 7 paramètres. Dans sa version la plus simple à 2 paramètres, le premier est l'image à coloriser, et le second est le nom du profil de colorisation, tel que trouvé dans la fenêtre de paramétrage, par exemple: `colorize(img(0), "h-alpha")`. Dans sa version longue, les paramètres de colorisation sont les points "entrée" et "sortie" pour chacun des canaux rouge, bleu et vert, entre 0 et 255. Par exemple: `colorize(img(0), 84, 139, 95, 20, 218, 65)` est équivalent à l'entrée précédente. Notez que la colorisation varie fortement en fonction des images en entrée et qu'il _peut_ être nécessaire d'avoir appliqué la fonction `asinh_stretch` avant pour obtenir les couleurs souhaitées.
- `rgb` permet de créer une image RGB à partir de 3 images mono. Elle prend donc 3 paramètres, par exemple: `rgb(img(3), avg(img(3), img(-3)), img(-3))`.
- `saturate` permet de (dé)saturer une image RGB. Elle accepte 2 paramètres : une image couleur et un facteur de saturation (relatif à la saturation courante de l'image). Par exemple: `saturate(doppler, 2)`.
- `anim` permet de créer une animation vidéo à partir de vos images individuelles. Elle accepte une list d'images en premier argument, et en 2ème optionnel le délai entre chaque image (par défaut 250ms). Par exemple `anim(range(-5;5))`. Attention: la création d'animations demande beaucoup de ressources système.
- `load` charge une image depuis le système de fichiers. Elle prend le chemin vers le fichier en paramètre. Par exemple: `load("/chemin/vers/une/image.png")`. Au lieu d'utiliser un chemin complet, il est possible de combiner avec la fonction `workdir`.
- `load_many` permet de charger plusieurs images d'un coup, à partir d'un dossier. Par exemple: `load_many("/chemin/vers/dossier")`. Un paramètre optionnel accepte une expression régulière pour filtrer les images: `load_many("/chemin/vers/dossier", ".\*cropped.*")`.
- `workdir` définit le dossier de travail par défaut. Il est notamment utilisé pour charger les images avec `load`. Par exemple: `workdir("/chemin/vers/dossier/images")`.
- `choose_file` permet à l'utilisateur de choisir une image depuis le système de fichiers. Elle prend 2 paramètres : un identifiant et un message d'aide. L'identifiant est utilisé pour se souvenir du dernier dossier utilisé. Par exemple : `choose_file("myImage", "Choisissez une image")`. Le message ne peut pas être vide.
- `choose_files` permet à l'utilisateur de choisir plusieurs images depuis le système de fichiers. Elle prend 2 paramètres : un identifiant et un message d'aide. L'identifiant est utilisé pour se souvenir du dernier dossier utilisé. Par exemple : `choose_files("myImage", "Choisissez plusieurs images")`. Le message ne peut pas être vide.
- `rl_decon` applique l'algorithme de déconvolution de Richardson-Lucy à l'image. Cette fonction utilise un PSF synthétique. Au minimum, cette fonction accepte un paramètre : l'image. Par exemple : `rl_decon(img(0))`. 3 autres paramètres optionnels sont disponibles : le rayon du PSF en pixels, le facteur sigma et le nombre d'itérations. Par exemple: `rl_decon(img(0), 2.5, 2.5, 10)`.
- `sharpen` applique un filtre d'augmentation des détails à votre image. Exemple: `sharpen(img(0))`.
- `blur` applique un flou gaussien à votre image. Par exemple : `blur(img(0))`.
- `disk_fill` remplit le disque solaire détecté avec une valeur donnée (par défault, celle du point noir détecté). Par exemple `disk_fill(img(0))` ou `disk_fill(img(0), 0)`.
- `rescale_rel` permet d'agrandir ou réduire la taille d'une image. Elle prend 3 paramètres: l'image, puis les facteurs d'agrandissement en X et Y. Par exemple, `rescale_rel(img(0);2;2)` pour doubler la taille d'une image.
- `rescale_abs` permet d'agrandir ou réduire la taille d'une image. Elle prend 3 paramètres: l'image, puis les dimensions finales souhaitées. Par exemple, `rescale_abs(img(0);2048;2048)`.
- `radius_rescale` est une méthode de redimensionnement relative qui peut être utile pour faciliter les mosaïques d'images. Elle sera donc typiquement utilisée en <<#batch-mode,traitement par lots>>. Elle permet de redimensionner un ensemble d'images pour que toutes aient le même rayon solaire. Elle procède à une recherche du disque pour chaque image, trouve celle qui a le disque le plus grand, et redimensionne toutes les autres images pour qu'elles aient le même rayon solaire. Par exemple: `radius_rescale(cropped)`.

Fonctions de rotation :

TIP: Une variable spéciale nommée `angleP` contient la valeur calculée pour l'angle P en fonction de la date d'observation. Elle est exprimée en radians et peut typiquement être utilisée avec la fonction `rotate_rad` pour effectuer une correction.

- `rotate_left` effectue une rotation vers la gauche de l'image. Par exemple, `rotate_left(img(0))`.
- `rotate_right` effectue une rotation vers la droite de l'image. Par exemple, `rotate_right(img(0))`.
- `rotate_deg` effectue une rotation d'un angle arbitraire en degrés. Elle accepte entre 2 et 4 paramètres: l'image, l'angle de rotation sont obligatoires. Par exemple `rotate_deg(img(0), 45)`. Vous pouvez ensuite spécifier la valeur du fond à utiliser pour remplir les portions manquantes:  `rotate_deg(img(0), 45, 800)` et enfin si vous ajoutez `1` en dernier paramètre l'image sera redimensionnée au maximum pour que tous les pixels de l'image d'origine apparaissent dans l'image tournée.
- `rotate_rad` effectue une rotation d'un angle arbitraire en radians. Elle accepte entre 2 et 4 paramètres: l'image, l'angle de rotation sont obligatoires. Par exemple `rotate_rad(img(0), .2)`. Vous pouvez ensuite spécifier la valeur du fond à utiliser pour remplir les portions manquantes:  `rotate_rad(img(0), .2, 800)` et enfin si vous ajoutez `1` en dernier paramètre l'image sera redimensionnée au maximum pour que tous les pixels de l'image d'origine apparaissent dans l'image tournée.
- `vflip` permet de retourner l'image verticalement. Par exemple, `vflip(img(0))`.
- `hflip` permet de retourner l'image horizontalement. Par exemple, `hflip(img(0))`.

Fonctions décoratives

- `draw_globe` dessine un globe dont l'orientation et le diamètre correspond aux paramètres solaires détectés. Elle prend entre 1 et 4 paramètres. Le premier est l'image sur laquelle dessiner le globe. Par exemple: `draw_globe(img(0))`. Les paramètres optionnels suivants sont l'angle P (en radians), l'angle B0 (en radians) et l'ellipse du disque solaire. Par exemple: `draw_globe(img(0), p, b0, ellipse)`.
- `draw_obs_details` affiche sur l'image les données d'observation. Par exemple: `draw_obs_details(img(0))`. Par défaut, positionné en haut à gauche. Il est possible de spéficier les coordonnées (x,y) où écrire : `draw_obs_details(img(0), 100, 100)`.
- `draw_solar_params` affiche sur l'image les paramètres solaires. Par exemple: `draw_solar_params(img(0))`. Par défaut, positionné en haut à droite. Il est possible de spéficier les coordonnées (x,y) où écrire : `draw_solar_params(img(0), 500, 100)`.
- `draw_text` imprime du texte sur l'image. Cette fonction prend 3 arguments obligatoires : l'image, la position où imprimer le texte, le texte à écrire. Par exemple : `draw_text(img(0), 100, 100, "Hello World")`. Elle accepte également 2 paramètres optionnels : la taille de la police et la couleur. Par exemple : `draw_text(img(0), 100, 100, "Hello World", 24, "ff0000")`. La couleur est une valeur hexadécimale RGB. NOTE : si vous spécifiez une couleur, alors l'image sera automatiquement convertie en RGB. Si le texte est entouré de `\*` alors il sera imprimé en gras. Par exemple, `draw_text(img(0), 100, 100, "\*Hello World\*")`. Si le texte est entouré de `\_` alors il sera imprimé en italique. Par exemple, `draw_text(img(0), 100, 100, "\_Hello World\_")`.
- `draw_arrow` dessine une flèche sur l'image. Cette fonction prend 5 arguments obligatoires : l'image, les points de départ et d'arrivée de la flèche. Par exemple : `draw_arrow(img(0), 100, 100, 200, 200)`. Elle accepte également 2 paramètres optionnels : l'épaisseur de la flèche et la couleur. Par exemple : `draw_arrow(img(0), 100, 100, 200, 200, 2, "ff0000")`. La couleur est une valeur hexadécimale RGB. NOTE : si vous spécifiez une couleur, alors l'image sera automatiquement convertie en RGB.
- `draw_circle` dessine un cercle sur l'image. Cette fonction prend 4 arguments obligatoires : l'image, le centre du cercle et le rayon. Par exemple : `draw_circle(img(0), 100, 100, 50)`. Elle accepte également 2 paramètres optionnels : l'épaisseur du cercle et la couleur. Par exemple : `draw_circle(img(0), 100, 100, 50, 2, "ff0000")`. La couleur est une valeur hexadécimale RGB. NOTE : si vous spécifiez une couleur, alors l'image sera automatiquement convertie en RGB.
- `draw_rect` dessine un rectangle sur l'image. Cette fonction prend 5 arguments obligatoires : l'image, les coordonnées du coin supérieur gauche, la largeur et la hauteur. Par exemple : `draw_rect(img(0), 100, 100, 200, 200)`. Elle accepte également 2 paramètres optionnels : l'épaisseur du rectangle et la couleur. Par exemple : `draw_rect(img(0), 100, 100, 200, 200, 2, "ff0000")`. La couleur est une valeur hexadécimale RGB. NOTE : si vous spécifiez une couleur, alors l'image sera automatiquement convertie en RGB.

Fonctions d'empilement et de création de mosaiques :

- `stack` permet d'empiler des images. Elle prend entre 1 et 3 paramètres. Le premier est la liste des images à empiler, par exemple: `stack(load_many("*.fits"))`. Le 2ème paramètre est la taille des tuiles et le 3ème est le facteur de recouvrement (entre 0 et 1).
- `mosaic` permet de créer une mosaïque d'images. Elle prend entre 1 et 3 paramètres. Le premier est la liste des images à empiler, par exemple: `mosaic(load_many("*.fits"))`. Le 2ème paramètre est la taille des tuiles et le 3ème est le facteur de recouvrement (entre 0 et 1).

Fonctions d'analyse :

- `find_shift` permet de calculer un décalage en pixels par rapport à la raie détectée. Elle accepte un seul paramètre, le nom de la raie recherchée, par exemple, `find_shift("Helium (D3)"), ou bien la longueur d'onde en Angström, par exemple `find_shift(5875.62)`. Cette fonction retourne un nombre, le décalage en pixels.
- `continuum` est une fonction sans paramètre qui détermine automatiquement une image de type "continuum" qui peut par exemple être soustraite d'une autre image. Cette fonction diffère de l'image continuum classique au sens où il ne s'agit pas d'une image unique calculée à la différence de pixels fixe de 15 pixels, mais d'une image calculée à partir de la médiane d'un ensemble d'images. Utilisation : `continuum()`.

Fonctions diverses :

- `sort` permet de trier une liste d'images. Elle accepte une liste d'images en premier argument et un critère de tri en second argument. Par exemple : `sort(images, "date")`. Le critère par défaut est `shift` pour le décalage en pixels.
- `video_datetime` retourne la date et l'heure formatée d'une image. Elle accepte un ou deux paramètres : l'image et un format optionnel. Par exemple : `video_datetime(img(0))` ou `video_datetime(img(0), "yyyy-MM-dd HH:mm:ss")`

=== Scripts ImageMath

Dans la section précédente, nous avons vu les "briques élémentaires" d'ImageMath, qui permettent de calculer des images.
Les scripts permettent d'efficacement combiner ces briques pour en faire de véritables outils puissants pour traiter vos images.

A titre d'exemple, voici un script qui permet de traiter une image dans la raie Hélium.

[source]
----
[params]
# The shifting between the helium line and the detected line (in pixels)
Line=5875.62
HeliumShift=find_shift(Line)
# Banding correction width and number of iterations
BandWidth=25
BandIterations=20
# Contrast adjustment
Gamma=1.5
# Autocrop factor (of diameter)
AutoCropFactor=1.1

## Temporary variables
[tmp]
helium_raw = img(HeliumShift) - continuum()
helium_fixed = fix_banding(helium_raw;BandWidth;BandIterations)
cropped = autocrop2(auto_contrast(helium_fixed;Gamma);AutoCropFactor)

## Let's produce the images now!
[outputs]
helium_mono = cropped
helium_color = colorize(helium_mono, Line)
----

Notre script est décomposé en 3 sections: `[params]`, `[tmp]` et `[outputs]`.
La seule section obligatoire est `[outputs]`: elle permet de définir quelles images nous souhaitons obtenir en sortie.
Le nom des autres sections est arbitraire, vous pouvez en définir autant que vous le souhaitez.

Ici, nous avons une section `[params]` qui permet de mettre en évidence les _paramètres de notre script_, autrement dit ce que l'utilisateur peut configurer.
On y trouve des variables, déclarées par un nom (ex `Line`) et une valeur `5875.62`.
La deuxième variable, `HeliumShift`, est calculée à partir de la fonction `find_shift`, qui prend en paramètre la variable `Line` (et permet de déterminer le décalage en pixels de la ligne par rapport à celle détectée).

NOTE: Une variable doit ne peut contenir que des caractères ascii, des numéros (hors premier caractère) ou le caractère _. Par exemple, `maVariable`, `MaVariable0` et `maVariable_0` sont tous valides, mais `hélium` ne l'est pas.

Ces variables peuvent être réutilisés dans d'autres variables ou des appels de fonctions.

IMPORTANT: Les variables sont sensibles à la casse. `maVariable` et `MaVariable` sont 2 variables distinctes !

Ainsi, notre 2ème section, `[tmp]`, définit des images qui nous servent d'intermédiaire de calculs, mais pour lesquelles nous ne sommes pas intéressés par le résultat.
Ici, nous calculons 3 images temporaires :

- `helium_raw` est l'image de la raie Hélium, décalée par rapport à la raie détectée et à laquelle on a soustrait l'image continuum.
- `helium_fixed` est l'image `helium_raw` à laquelle on a appliqué l'algorithme de correction de transversalliums.
- `cropped` est l'image `helium_fixed` à laquelle on a appliqué un rognage automatique et un ajustement de contraste.

Au final, la section `[outputs]` déclare les images qui nous intéressent :

- `helium_mono` est l'image `cropped` telle quelle, en noir et blanc.
- `helium_color = colorize(fix_banding(helium_raw;BandWidth;BandIterations), "Helium (D3)")` permet d'obtenir une version colorisée.

NOTE: Vous pouvez mettre des commentaires sur une ligne commençant par `#` ou `//`

[[batch-mode]]
== Traitement par lots

En plus du traitement individuel, JSol'Ex propose une mécanique de traitement par lot.
Dans ce mode, plusieurs vidéos sont traitées en parallèle, permettant de générer rapidement un grand nombre d'images, qui peuvent par exemple être ensuite envoyées dans un logiciel d'empilement tel qu'AutoStakkert!.

Pour lancer un traitement en lot, il faut aller dans le menu "Fichier" et cliquer sur "Traiter un lot".
Sélectionnez alors l'ensemble des fichiers SER à traiter (ils doivent se trouver dans un seul et même dossier).

La même fenètre de paramétrage que dans le mode fichier seul s'ouvre alors.
Elle permet de configurer le traitement, mais cette fois si pour le lot complet.
Lorsque le traitement est lancé, il y a cependant quelques différences:

1. les fichiers seront systématiquement enregistrés, indépendemment de la case "enregistrement automatique des images"
2. les images ne s'affichent pas dans l'interface, mais une liste des fichiers traités à la place

image::batch-mode-fr.jpg[]

La liste des fichiers comprend le _fichier de log_ du traitement de ce fichier, ainsi que toutes les images générées pour ce fichier.

NOTE: En mode batch, nous recommendons d'utiliser un <<#modele-noms-fichier,modèle de nom de fichier>> qui met toutes les images dans le même dossier, ce qui rendra plus simple leur exploitation dans un programme tiers.

=== Extensions d'ImageMath disponibles en mode batch

Lorsque vous utilisez le mode batch, une nouvelle section est disponible dans les <<#imagemath,scripts ImageMath>>.
Cette section permet de composer des images à partir du résultat du traitement de chaque image individuelle.
Typiquement, ceci peut-être utilisé pour faire de l'empilement.

Cette section doit apparaître en fin de script et se délimite par le bloc `\[[batch]]`:

[source]
----
#
# Empile des images en utilisant le mode batch
#

[params]
# banding correction width and iterations
bandingWidth=25
bandingIterations=3
# autocrop factor
cropFactor=1.1
# contrast adjustment
clip=.8

[tmp]
corrected = fix_banding(img(0);bandingWidth;bandingIterations) # <1>
contrast_fixed = clahe(corrected;clip)                         # <2>

[outputs]
cropped = autocrop2(contrast_fixed;cropFactor;32)              # <3>

# This is where we stack images, simply using a median
# and assuming all images will have the same output size
[[batch]]                                                      # <4>
[outputs]
stacked=sharpen(median(cropped))                               # <5>
----
<1> Pour chaque film, on calcule une image intermédiaire corrigée (qui ne sera pas stockée sur disque)
<2> On applique une correction de contraste sur cette image corrigée
<3> Important pour l'empilement : on réduit les images à un carré centré sur le disque solaire et on arondit les dimensions à un multiple de 32 pixels. Il s'agit de notre image de sortie pour chaque film du lot.
<4> On déclare une section `\[[batch]]` pour décrire la sortie du mode batch
<5> Une image nommée `stacked` sera calculée en utilisant la médiane des images `cropped`

Il est important de bien comprendre que seules les images apparaissant dans la partie `[outputs]` du traitement individiduel peuvent être utilisées dans la section `\[[batch]]`.
Ainsi, une image `cropped` apparaissant dans la partie individuelle devient implicitement une _liste_ d'images dans la section `\[[batch]]`: on travaille bien sur la liste des images générées dans le lot !

Certaines fonctions comme `img` ne sont pas disponibles dans le mode `batch`.
Si vous avez besoin d'images individuelles, vous devez les stocker dans une variable de sortie.
Par exemple:

[source]
----
[outputs]
frame=img(0)       # <1>

[[batch]]
[outputs]
video=anim(frame)  # <2>
----
<1> Pour que `img(0)` soit disponible dans la section `batch`, on l'assigne dans une variable nommée `frame`
<2> On crée une animation dont chaque image est constituée d'une `frame`

=== Scripts indépendants

Une dernière façon d'utiliser des scripts est de réutiliser des résultats de sessions précédentes (typiquement des images traitées lors d'une ou plusieurs sessions) sans avoir besoin de traiter une nouvelle vidéo.

Pour se faire, vous pouvez passer par le menu "Outils" puis "Editeur ImageMath".
L'interface qui apparaît est exactement la même que lors du traitement d'une vidéo ou d'un lot de vidéos.
La principale différence dans ce mode est que les images doivent être chargées avec les fonctions `load` ou `load_many` (au lieu d'utiliser `img`).

IMPORTANT: Si vous utilisez ce mode, il est important de charger des images enregistrées au format FITS. En effet, ces images contiennent des métadonnées telles que les ellipses détectées, les paramètres de traitement, etc. qui permettent de faire les mêmes traitements avec des images enregistrées sur disque que ceux obtenus dans une session de traitement classique.

== Mesures

=== Mesures de décalage vers le rouge

Si vous traitez une image H-alpha, JSol'Ex peut automatiquement rechercher dans l'image des régions où le _redshift_ (décalage vers le rouge ou vers le bleu) est particulièrement fort.

Pour se faire, vous devez soit sélectionner le mode "complet" lors du traitement, soit cocher la case "Mesures de décalage vers le rouge" dans la sélection personnalisée des images.

Les mesures ne seront valides **que** si la taille des pixels renseignée est correcte **et** que vous utilisez un Sol'Ex (d'autres spectrohéliographes ont des focales différentes).

Lors du traitement, une image supplémentaire sera générée avec les régions entourées en rouge et la vitesse associée.

De plus, si vous sélectionnez les images de débug, les parties du spectre ayant permis de trouver ces régions seront affichées.

Enfin, une fois la détection effectuée, il vous est possible de générer 2 nouveaux types de rendus, en vous rendant sur l'onglet "Redshift":

image::redshift-tab.jpg[]

La taille correspond à la taille minimale de la région à capturer, en pixels.
Une petite région sera centrée autour du filament détecté, mais pourra être assez pixelisée selon les cas.
La marge permet de choisir combien, en décalage de pixels, prendre de marge par rapport à ce qu'a détecté JSol'Ex.
Par exemple, JSol'Ex peut trouver un décalage maximum de 20 pixels, mais vous pouvez souhaiter ajouter 2 ou 4 pixels de marge pour une animation et bien voir apparaître le filament.

Enfin, sélectionnez le type de rendu :

- Animation : génère une vidéo dont chaque image est décalée de 0.25 pixels
- Panneau : génère une seule image, un panneau où chaque case correspond à un décalage de pixels différent

image::pixel-shift-panel.jpg["Example of panel"]

=== Mesures avec le débogueur de spectre

JSol'Ex propose un outil permettant de visualiser la détection des lignes spectrales sur une vidéo.
Cet outil peut être utilisé pour trouver, par exemple, le décalage de pixels à appliquer pour trouver la raie hélium.

Pour se faire, ouvrez une vidéo en cliquant sur "Outils -> Débogueur de spectre".
Le logiciel va calculer l'image moyenne pour la vidéo puis vous présenter cette fenêtre:

image::spectral-debug-1-fr.jpg[]

En haut, vous voyez l'image moyenne.
La ligne rouge correspond à la ligne spectrale détectée.
Sous la ligne violette s'affiche une image _corrigée en fonction du polynôme_ : ceci vous permet de vérifier facilement si le polynôme est correct: l'image du bas doit avoir des lignes spectrales parfaitement horizontales.

Dans la partie basse de l'interface, vous trouverez:

- le bouton radio "Moyenne / Images" qui permet de basculer entre l'image moyenne et les images individuelles du film SER
- lorsque "Images" est sélectionné, le slider à droite permet de naviguer dans la vidéo
- le seuil de détection du soleil peut être changé (non recommandé, le logiciel ne permet pas de modifier cette valeur, c'est un mode expert)
- la case "vérouiller le polynôme" permet de figer la détection de ligne spectrale sur l'image actuelle : elle nous sera utile pour les mesures de distances
- le slider "contraste" permet d'augmenter le contraste et la luminosité de l'image (transformation arcsin hyperbolique)

=== Application au calcul de décalage de la raie hélium

Nous supposerons ici que notre fichier SER est une vidéo incluant à la fois la raie spectrale Hélium et une autre raie suffisamment sombre pour être bien détectée par JSol'Ex.

Nous pouvons alors procéder par étapes.

- vérouiller le polynôme sur l'image moyenne

image::spectral-debug-2-fr.jpg[]

- sélectionner le mode "Images"

image::spectral-debug-3-fr.jpg[]

- Augmenter le contraste

image::spectral-debug-4-fr.jpg[]

- Choisir une image au bord du limbe

image::spectral-debug-5-fr.jpg[]

Nous pouvons désormais effectuer des mesures.
Lorsque vous déplacez la souris sur l'image, des coordonnées s'affichent :

image::spectral-debug-6-fr.jpg[]

Les 2 premiers nombres sont les coordonnées (x,y) du point sous le curseur de la souris.
Le 3ème nombre est celui qui nous intéresse : c'est le décalage en pixels entre le point sous le curseur et la ligne spectrale en rouge.

Le 4ème nombre nous permet d'obtenir une mesure plus précise, en calculant une moyenne sur un nombre d'échantillons.

Pour ajouter un échantillon, trouvez un point sur la raie hélium et appuyez sur "CTRL" tout en cliquant.
Vous pouvez ajouter autant de points que vous le souhaitez:

image::spectral-debug-7-fr.jpg[]

Le 4ème nombre représente la distance moyenne calculée.
**Nous en déduisons que le décalage de pixels à appliquer est de -134**.

[[stacking-and-mosaic]]
== Empilement et création de mosaiques

JSol'Ex dispose d'un outil permettant d'empiler des images et de créer des mosaïques.
Les 2 outils sont très similaires, mais l'empilement est plus simple à utiliser.
L'empilement consiste à prendre plusieurs images de la même région du soleil et à en faire une seule image, en alignant les détails et en moyennant les pixels.
La mosaïque consiste à prendre plusieurs images de régions différentes du soleil et à les assembler pour former une image plus grande.

Les 2 outils sont disponibles en passant par le menu "Outils" puis "Empilement et création de mosaïques".

La fenêtre qui s'ouvre est la suivante:

image::stacking-1-fr.jpg[]

A gauche, vous pouvez créer des panneaux d'images à empiler.
Si vous ne créez qu'un seul panneau, il s'agira d'un empilement simple.
Si vous créer plusieurs panneaux, il s'agira d'une mosaïque.
Un panneau contiendra une ou plusieurs images, qui seront empilées ensemble.
Pour créer un panneau, vous pouvez, au choix:
- cliquer sur le bouton "+" et sélectionner les images à empiler
- faire un glisser-déposer d'une ou plusieurs images depuis votre explorateur de fichiers

image::stacking-2-fr.jpg[]

Dans l'image ci-dessus, nous avons créé 2 panneaux.
Le premier contient 3 images qui seront empilées pour faire le panneau nord, et le second contient 2 images qui seront empilées pour faire le panneau sud.

Les options d'empilement sont visibles à droite.
Il n'est pas recommandé de les modifier, sauf si vous savez ce que vous faites.
Les options sont les suivantes:
- la taille des tuiles permet de découper l'image en tuiles pour l'empilement. Plus la taille est petite, plus l'empilement sera précis mais le calcul sera plus long et il ne sera pas possible de découvrir des décalages importants entre les images.
- le chevauchement permet d'améliorer la qualité du résultat en faisant le même calcul avec une fenêtre glissante. Plus le chevauchement est grand, plus le résultat sera précis mais le calcul sera plus long.
- Forcer le recalcul des ellipses permet de recalculer l'ellipse (ou le cercle) du disque solaire pour chaque image. Ceci est utile notamment si vous utilisez des images venant d'un autre logiciel ou que les ellipses ont été mal détectées.
- Corriger la géométrie permet de rendre le disque solaire parfaitement circulaire, ce qui est généralement une bonne idée si les images que vous importez n'ont pas été corrigées.

Le script de post-traitement vous permet de sélectionner un script `ImageMath` à appliquer à chaque image après empilement.

NOTE: Dans un script de post-traitement, l'image empilée est disponible sous le nom de `image`. Par exemple, vous pouvez créer un script qui appliquera une déconvolution en utilisant la formule `rl_decon(image)`.

Les autres options disponibles sont celles de sélection des formats de fichier.
Si vous avez créé plusieurs panneaux, nous passons alors en mode mosaïque.
Non seulement les images seront empilées dans chaque panneau, mais chaque image empilée sera ensuite assemblée pour former une mosaïque.

WARNING: Il est recommandé de ne PAS utiliser d'images traitées (par exemple avec amélioration de contraste) pour la création de mosaïques. En effet, ces images sont plus difficiles à aligner. Il est donc recommandé d'utiliser les images `recon` (corrigée géométriquement) ou `raw` (brute).

image::stacking-3-fr.jpg[]

Si vous souhaitez simplement empiler des images sans faire de mosaique, vous pouvez désactiver l'option "Créer la mosaïque".
Dans le cas contraire, vous disposez de paramètres qu'il est possible de modifier, encore une fois, si vous savez ce que vous faites.
Nous recommandons de ne pas changer la taille des tuiles et le chevauchement pour la mosaïque, sauf si vous obtenez des images déformées ou non reconstruites.

Vous pouvez aussi choisir un script de post-traitement à appliquer après la création de la mosaïque.

== Calculatrice d'exposition optimale

Dans le menu "Outils", vous trouverez la calculatrice d'exposition optimale.
Cette calculatrice vous permet de déterminer le temps d'exposition optimal que vous devrez utiliser pour obtenir une image du soleil parfaitement ronde et éviter le sous-échantillonage.

Entrez :

- la taille des pixels de votre caméra et le binning utilisé
- la longueur focale de votre instrument
- la vitesse du scan (en multiple de la vitesse sidérale, par exemple 2, 4, 8, ...)
- la déclinaison du soleil en degrés au moment de l'observation

Le logiciel calculera alors l'exposition optimale en fonction de ces paramètres, en millisecondes.

== Remerciements

- Christian Buil pour avoir conçu le Sol'Ex et diriger la communauté d'une main de maître
- Valérie Desnoux pour son travail remarquable sur INTI
- Jean-François Pittet pour ses rapports de bugs, ses vidéos de test et ses formules de correction géométrique
- Sylvain Weiller pour son beta-testing intensif, ses retours précieux et ses idées de traitement
- Ken M. Harrison pour l'amélioration des calculs d'exposition optimale
