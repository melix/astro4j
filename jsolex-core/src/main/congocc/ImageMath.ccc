DEFAULT_LEXICAL_STATE=IMAGEMATH;
PARSER_PACKAGE="me.champeau.a4j.jsolex.expr";
ENSURE_FINAL_EOL;
FAULT_TOLERANT;
FAULT_TOLERANT_DEFAULT=false;

INJECT PARSER_CLASS:
{
    private Path includeDir = Path.of(".");

    public void setIncludeDir(Path includeDir) {
        this.includeDir = includeDir;
    }

    public void parse() {
        Root();
        var root = (ImageMathScript) rootNode();
        root.setIncludeDir(includeDir);
        root.resolveIncludes();
    }

    public ImageMathScript parseAndInlineIncludes() {
        parse();
        inlineIncludes();
        return (ImageMathScript) rootNode();
    }
    public void inlineIncludes() {
        var root = (ImageMathScript) rootNode();
        root.inlineIncludes();
    }
}

INCLUDE "ImageMathLexer.ccc"

Root#ImageMathScript : (IncludeDef! | FunctionDef! | MetaBlock!)* (IncludeDef! | FirstSection!) ( IncludeDef! | SubsequentSection! )* <EOF>;

INJECT ImageMathScript:
import java.nio.file.Path;
import java.nio.file.Files;
import me.champeau.a4j.jsolex.processing.expr.ImageMathScriptExecutor;
{

    private Path includeDir = Path.of(".");

    public void setIncludeDir(Path includeDir) {
        this.includeDir = includeDir == null ? Path.of(".") : includeDir;
    }

    public void resolveIncludes() {
        var nodes = children();
        if (nodes.stream().anyMatch(node -> node instanceof IncludeDef)) {
            for (var node: nodes) {
                if (node instanceof IncludeDef include) {
                    var path = include.firstChildOfType(StringLiteral.class).toString();
                    try {
                        var resolved = includeDir.resolve(path);
                        if (!Files.exists(resolved)) {
                            resolved = includeDir.resolve(path + ".math");
                        }
                        var script = new ImageMathParser(resolved);
                        script.setIncludeDir(includeDir);
                        script.parse();
                        include.setIncludedNodes(
                            script.rootNode()
                                .children()
                                .stream()
                                .filter(t -> !(t instanceof Token token && token.getType().isEOF()))
                                .toList()
                        );
                        } catch (Exception e) {
                            // e.printStackTrace();
                        }
                }
            }
        }
    }

    public void inlineIncludes() {
        var nodes = children();
        if (nodes.stream().anyMatch(node -> node instanceof IncludeDef)) {
            var newNodes = new ArrayList<Node>();
            for (var node : nodes) {
                if (node instanceof IncludeDef include && !include.isUnresolved()) {
                    newNodes.addAll(include.includedNodes());
                } else {
                    newNodes.add(node);
                }
            }
            clear();
            addAll(newNodes);
        }
    }

    public List<Section> findSections(ImageMathScriptExecutor.SectionKind kind) {
        var allSections = childrenOfType(Section.class);
        var standardSections = new ArrayList<Section>(allSections.size());
        var batchSections = new ArrayList<Section>(allSections.size());
        boolean isInBatch = false;
        for (var section : allSections) {
            if (isInBatch) {
                batchSections.add(section);
            } else {
                var header = section.childrenOfType(SectionHeader.class);
                if (!header.isEmpty()) {
                    var first = header.getFirst();
                    if (first.isMajor() && "batch".equals(first.id())) {
                        isInBatch = true;
                        batchSections.add(section);
                    } else if (first.isMajor() && "params".equals(first.id())) {
                        // Skip params sections in both single and batch modes
                        continue;
                    } else if (first.isMajor() && "single".equals(first.id())) {
                        // [[single]] sections are treated as standard sections
                        standardSections.add(section);
                    } else {
                        standardSections.add(section);
                    }
                } else {
                    standardSections.add(section);
                }
            }
        }
        return Collections.unmodifiableList(kind == ImageMathScriptExecutor.SectionKind.SINGLE ? standardSections : batchSections);
    }

    public Optional<Section> findParamsSection() {
        // Look for top-level meta blocks containing params
        var metaBlocks = childrenOfType(MetaBlock.class);
        if (!metaBlocks.isEmpty()) {
            // Return the first section we can find for compatibility,
            // the actual parameters will be extracted via getTopLevelParameterDefs()
            return childrenOfType(Section.class).stream().findFirst();
        }
        return Optional.empty();
    }

    public List<ParameterDef> getTopLevelParameterDefs() {
        var metaBlocks = childrenOfType(MetaBlock.class);
        for (var metaBlock : metaBlocks) {
            var content = metaBlock.getContent();
            var paramsBlocks = content.childrenOfType(ParametersBlock.class);
            for (var paramsBlock : paramsBlocks) {
                if (paramsBlock.isParams()) {
                    return paramsBlock.getParameterDefs();
                }
            }
        }
        return Collections.emptyList();
    }
}

FirstSection#Section : [SectionHeader] SectionContent;

SubsequentSection#Section : SectionHeader SectionContent;

SectionContent#void:
    (Assignment | MetaBlock)*;

INJECT Section:

import me.champeau.a4j.jsolex.processing.expr.ImageMathScriptExecutor;

{
    public java.util.Optional<String> name() {
        var header = firstChildOfType(SectionHeader.class);
        if (header == null) {
            return java.util.Optional.empty();
        }
        var identifier = header.firstChildOfType(Identifier.class);
        if (identifier != null) {
            return java.util.Optional.of(identifier.toString());
        }
        // Check if it's the special "params" case
        var tokens = header.childrenOfType(Token.class);
        for (var token : tokens) {
            if (token.getType() == Token.TokenType.PARAMS) {
                return java.util.Optional.of("params");
            }
        }
        return java.util.Optional.empty();
    }

    public List<ParameterDef> getParameterDefs() {
        // Look for meta blocks with params in this section
        var metaBlocks = childrenOfType(MetaBlock.class);
        for (var metaBlock : metaBlocks) {
            var content = metaBlock.getContent();
            var paramsBlocks = content.childrenOfType(ParametersBlock.class);
            for (var paramsBlock : paramsBlocks) {
                if (paramsBlock.isParams()) {
                    return paramsBlock.getParameterDefs();
                }
            }
        }

        // If no meta blocks in this section, check the script level
        var parent = getParent();
        while (parent != null && !(parent instanceof ImageMathScript)) {
            parent = parent.getParent();
        }
        if (parent instanceof ImageMathScript script) {
            return script.getTopLevelParameterDefs();
        }

        return Collections.emptyList();
    }

}

SectionHeader :
(
    <LBRACKET> (
        (<LBRACKET> <IDENTIFIER> <RBRACKET> <RBRACKET>) { thisProduction.setMajor(true); }# |
        (<IDENTIFIER> | "params") <RBRACKET>
    )
);

INJECT SectionHeader:
{
    private boolean major;

    public boolean setMajor(boolean major) {
        this.major = major;
        return major;
    }

    public boolean isMajor() {
        return major;
    }

    public String id() {
        return firstChildOfType(Identifier.class).toString();
    }
}

Expression: AdditiveExpression;

AdditiveExpression#Expression :
   MultiplicativeExpression
   (
     ( <PLUS> | <MINUS> ) MultiplicativeExpression
     #BinaryExpression(3)
   )*
;

MultiplicativeExpression#Expression :
   UnaryExpression
   (
     ( <MUL> | <DIV> ) UnaryExpression
     #BinaryExpression(3)
   )*
;

UnaryExpression#void :
  ((<PLUS>|<MINUS>) PrimaryExpression #UnaryExpression(2))
  |
  PrimaryExpression;

INJECT UnaryExpression: extends Expression
{
    public Operator operator() {
        return firstChildOfType(Operator.class);
    }

    public Expression operand() {
        return firstChildOfType(Expression.class);
    }
}

INJECT BinaryExpression: extends Expression
{
    public Operator operator() {
        return firstChildOfType(Operator.class);
    }

    public Node left() {
        return children().getFirst();
    }

    public Node right() {
        return children().getLast();
    }

}

PrimaryExpression#void:
    FunctionCall! |
    StringLiteral |
    NumericalLiteral |
    VariableExpression |
    GroupedExpression!;

GroupedExpression:
    <LPAREN> Expression <RPAREN>;

INJECT GroupedExpression: extends Expression;

VariableExpression#VariableExpression :
    <IDENTIFIER>;

INJECT VariableExpression: extends Expression
{
    public Identifier id() {
        return firstChildOfType(Identifier.class);
    }
}

FunctionCall:
    <IDENTIFIER> InvocationArguments =>|| ;

INJECT FunctionCall: extends Expression;

Assignment#Assignment :
    (VariableExpression <ASSIGNMENT> Expression  =>||) | Expression ;

INJECT Assignment: extends Expression
{
    private String variable;

    public void setVariable(String variable) {
        this.variable = variable;
    }

    public boolean isAnonymous() {
        return variable().isEmpty();
    }

    public Optional<Identifier> variable() {
        return Optional.ofNullable(firstChildOfType(VariableExpression.class)).map(VariableExpression::id);
    }

    public Optional<String> variableName() {
        return variable().map(Object::toString).or(() -> Optional.ofNullable(variable));
    }

    public Expression expression() {
        return childrenOfType(Expression.class).getLast();
    }
}

INJECT UnaryExpression: extends Expression
{
    public Expression getExpression() {
        return firstChildOfType(Expression.class);
    }
}

StringLiteral#StringLiteral :
   <SINGLE_QUOTE_STRING>
   |
   <DOUBLE_QUOTE_STRING>
   |
   <MULTILINE_STRING>
;

INJECT StringLiteral: extends Expression
{

    public String toString() {
        var value = super.toString();
        int dlen = 1;
        if (value.startsWith("\"\"\"")) {
            dlen = 3;
        }
        return value.substring(dlen, value.length() - dlen)
            .replace("\\\\", "\\")
            .replace("\\\"", "\"");
    }
}

NumericalLiteral#NumericalLiteral :
   <INTEGER_LITERAL>
   |
   <FLOATING_POINT_LITERAL>
;

INJECT NumericalLiteral: extends Expression;

NamedArgument :
    <IDENTIFIER> <COLON> Expression =>||;

INJECT NamedArgument : extends Argument
{
    public String getName() {
        return firstChildOfType(Identifier.class).toString();
    }

    public Expression getValue() {
        return firstChildOfType(Expression.class);
    }
}

Argument:
    NamedArgument | Expression;

InvocationArguments :
    <LPAREN>
    [ Argument#Argument ((<COMMA>|<SEMICOLON>) Argument#Argument)* ]
    <RPAREN>
;

INJECT FunctionCall:
    import me.champeau.a4j.jsolex.expr.BuiltinFunction;
 {

    public Identifier getFunction() {
        return firstChildOfType(Identifier.class);
    }

    public String getFunctionName() {
        return firstChildOfType(Identifier.class).toString();
    }
    public List<Argument> getArguments() {
        var argList = firstChildOfType(InvocationArguments.class);
        if (argList != null) {
            return argList.childrenOfType(Argument.class);
        }
        return List.of();
    }

    public Optional<BuiltinFunction> getBuiltinFunction() {
        var name = getFunctionName();
        try {
            return Optional.of(BuiltinFunction.valueOf(name.toUpperCase(Locale.US)));
        } catch (IllegalArgumentException e) {
            return Optional.empty();
        }
    }
}

FunctionDef:
    <LBRACKET> <FUNCTION> <COLON> <IDENTIFIER> (FunctionParams#FunctionParams) <RBRACKET> (Assignment)* =>||;

FunctionParams#void: (<IDENTIFIER>)*;

INJECT FunctionDef:
{

    public String name() {
        return ((Identifier) children().get(3)).toString();
    }

    public List<String> arguments() {
        var params = firstChildOfType(FunctionParams.class);
        if (params != null) {
            return params.childrenOfType(Identifier.class).stream().map(Identifier::toString).toList();
        }
        return List.of();
    }

    public List<Expression> body() {
        return childrenOfType(Assignment.class).stream().map(Expression.class::cast).toList();
    }
}

IncludeDef:
    <LBRACKET> <INCLUDE> StringLiteral <RBRACKET> =>||;

INJECT IncludeDef:
{
    private List<Node> includedNodes;

    public void setIncludedNodes(List<Node> includedNodes) {
        this.includedNodes = includedNodes;
    }

    public List<Node> includedNodes() {
        return includedNodes;
    }

    public boolean isUnresolved() {
        return includedNodes == null;
    }
}

ParameterDef:
    <IDENTIFIER> ParameterObject;

INJECT ParameterDef:
{
    public String getName() {
        return firstChildOfType(Identifier.class).toString();
    }

    public ParameterObject getObjectValue() {
        return firstChildOfType(ParameterObject.class);
    }

    public StringLiteral getStringValue() {
        return firstChildOfType(StringLiteral.class);
    }

    public NumericalLiteral getNumberValue() {
        return firstChildOfType(NumericalLiteral.class);
    }

    public ParameterArray getArrayValue() {
        return firstChildOfType(ParameterArray.class);
    }

    public Object getValue() {
        var obj = getObjectValue();
        if (obj != null) return obj;
        var str = getStringValue();
        if (str != null) return str;
        var num = getNumberValue();
        if (num != null) return num;
        var arr = getArrayValue();
        if (arr != null) return arr;
        return null;
    }
}

ParameterValue:
    ParameterObject |
    StringLiteral |
    NumericalLiteral;

ParameterObject:
    <LBRACE> (ParameterProperty)* <RBRACE>;

INJECT ParameterObject:
{
    public List<ParameterProperty> getProperties() {
        return childrenOfType(ParameterProperty.class);
    }

    public Optional<String> getProperty(String name) {
        return getProperties().stream()
            .filter(prop -> name.equals(prop.getName()))
            .map(ParameterProperty::getStringValue)
            .filter(Optional::isPresent)
            .map(Optional::get)
            .findFirst();
    }

    public Optional<Number> getNumberProperty(String name) {
        return getProperties().stream()
            .filter(prop -> name.equals(prop.getName()))
            .map(ParameterProperty::getNumberValue)
            .filter(Optional::isPresent)
            .map(Optional::get)
            .findFirst();
    }
}

ParameterProperty:
    <IDENTIFIER> (<ASSIGNMENT> ParameterPropertyValue | ParameterObject);

INJECT ParameterProperty:
{
    public String getName() {
        return firstChildOfType(Identifier.class).toString();
    }

    public ParameterPropertyValue getValue() {
        var value = firstChildOfType(ParameterPropertyValue.class);
        if (value != null) {
            return value;
        }
        // Fallback: if ParameterPropertyValue is optimized away, create a virtual one
        var virtualValue = new ParameterPropertyValue();
        virtualValue.addAll(childrenOfType(StringLiteral.class));
        virtualValue.addAll(childrenOfType(NumericalLiteral.class));
        virtualValue.addAll(childrenOfType(ParameterObject.class));
        virtualValue.addAll(childrenOfType(ParameterArray.class));
        return virtualValue;
    }

    public Optional<String> getStringValue() {
        var value = getValue();
        if (value.firstChildOfType(StringLiteral.class) != null) {
            return Optional.of(value.firstChildOfType(StringLiteral.class).toString());
        }
        return Optional.empty();
    }

    public Optional<Number> getNumberValue() {
        var value = getValue();
        var numLiteral = value.firstChildOfType(NumericalLiteral.class);
        if (numLiteral != null) {
            try {
                var str = numLiteral.toString();
                if (str.contains(".")) {
                    return Optional.of(Double.parseDouble(str));
                } else {
                    return Optional.of(Long.parseLong(str));
                }
            } catch (NumberFormatException e) {
                return Optional.empty();
            }
        }
        return Optional.empty();
    }
}

ParameterPropertyValue:
    StringLiteral |
    NumericalLiteral |
    ParameterObject |
    ParameterArray;

ParameterArray:
    <LBRACKET> [StringLiteral ((<COMMA>|<SEMICOLON>) StringLiteral)*] <RBRACKET>;

INJECT ParameterArray:
{
    public List<StringLiteral> getElements() {
        return childrenOfType(StringLiteral.class);
    }
}

MetaBlock:
    <META> <LBRACE> MetaContent <RBRACE>;

INJECT MetaBlock:
{
    public String getName() {
        return "meta";
    }

    public MetaContent getContent() {
        var content = firstChildOfType(MetaContent.class);
        if (content != null) {
            return content;
        }
        // Fallback: if MetaContent is optimized away, create a virtual one
        var virtualContent = new MetaContent();
        virtualContent.addAll(childrenOfType(ParametersBlock.class));
        virtualContent.addAll(childrenOfType(MetaProperty.class));
        return virtualContent;
    }

}

MetaContent:
    (ParametersBlock | MetaProperty)*;

INJECT MetaContent:
{
    public List<ParametersBlock> getParametersBlocks() {
        return childrenOfType(ParametersBlock.class);
    }

    public List<MetaProperty> getMetaProperties() {
        return childrenOfType(MetaProperty.class);
    }
}

MetaProperty:
    <IDENTIFIER> (<ASSIGNMENT> (StringLiteral | NumericalLiteral) | ParameterObject);

ParametersBlock:
    <PARAMS> <LBRACE> (ParameterDef)* <RBRACE>;

INJECT ParametersBlock:
{
    public String getName() {
        return "params";
    }

    public boolean isParams() {
        return true;
    }

    public List<ParameterDef> getParameterDefs() {
        return childrenOfType(ParameterDef.class);
    }
}
